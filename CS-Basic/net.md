- [计网相关](#%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3)
  - [URI & URL](#uri-url)
  - [状态码](#%E7%8A%B6%E6%80%81%E7%A0%81)
    - [1xx 信息](#1xx-%E4%BF%A1%E6%81%AF)
    - [2xx 成功](#2xx-%E6%88%90%E5%8A%9F)
    - [3xx 重定向](#3xx-%E9%87%8D%E5%AE%9A%E5%90%91)
    - [4xx 客户端错误](#4xx-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF)
    - [5xx 服务端错误](#5xx-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%94%99%E8%AF%AF)
  - [缓存相关](#%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3)
    - [强缓存](#%E5%BC%BA%E7%BC%93%E5%AD%98)
    - [协商缓存](#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98)
    - [缓存头部对比](#%E7%BC%93%E5%AD%98%E5%A4%B4%E9%83%A8%E5%AF%B9%E6%AF%94)

# 计网相关

## URI & URL
  - URI = Universal Resource **Identifier** 统一资源标识符
  - URL = Universal Resource **Locator** 统一资源定位符
  - URN = Universal Resource Name 统一资源名称

  这三者关系如下图：

  ![Relationship between URI/URL/RUN.png](./images/uri&url&urn.png)

  URL代表资源的路径地址，而URI代表资源的唯一标识符。

## 状态码
  ### 1xx 信息
  code | 状态 | 描述
  -- | ---- | --------
  100 | Continue | 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。
  101 | Switching Protocols	| 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。

  ### 2xx 成功
  code | 状态 | 描述
  -- | ---- | --------
  **200** | OK	|请求成功（其后是对GET和POST请求的应答文档。）
  201 | Created	|请求被创建完成，同时新的资源被创建。
  202 | Accepted	|供处理的请求已被接受，但是处理未完成。
  203 | Non-authoritative Information|文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。
  204 | No Content|	没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。
  205 | Reset Content|	没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。
  206 | Partial Content|	客户发送了一个带有Range头的GET请求，服务器完成了它。

  ### 3xx 重定向
  code | 状态 | 描述
  -- | ---- | --------
  300 | Multiple Choices |	多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。
  301 | Moved Permanently |	所请求的页面已经转移至新的url。(永久移动) 
  302 | Found |	所请求的页面已经临时转移至新的url。(临时移动) 
  303 | See Other |	所请求的页面可在别的url下被找到。
  **304** | Not Modified |	未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。
  305 | Use Proxy |	客户请求的文档应该通过Location头所指明的代理服务器提取。
  306 | Unused |	此代码被用于前一版本。目前已不再使用，但是代码依然被保留。
  307 | Temporary Redirect |	被请求的页面已经临时移至新的url。

  ### 4xx 客户端错误
  code | 状态 | 描述
  -- | ---- | --------
  **400** | Bad Request |	服务器未能理解请求。
  **401** | Unauthorized |	被请求的页面需要用户名和密码。
  402 | Payment Required |	此代码尚无法使用。
  **403** | Forbidden |	对被请求页面的访问被禁止。
  **404** | Not Found |	服务器无法找到被请求的页面。
  **405** | Method Not Allowed |	请求中指定的方法不被允许。
  406 | Not Acceptable |	服务器生成的响应无法被客户端所接受。
  407 | Proxy Authentication Required |	用户必须首先使用代理服务器进行验证，这样请求才会被处理。
  408 | Request Timeout |	请求超出了服务器的等待时间。
  409 | Conflict |	由于冲突，请求无法被完成。
  410 | Gone |	被请求的页面不可用。
  411 | Length Required |	"Content-Length" 未被定义。如果无此内容，服务器不会接受请求。
  412 | Precondition Failed |	请求中的前提条件被服务器评估为失败。
  413 | Request Entity Too Large |	由于所请求的实体的太大，服务器不会接受请求。
  414 | Request-url Too Long |	由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。
  415 | Unsupported Media Type |	由于媒介类型不被支持，服务器不会接受请求。

  ### 5xx 服务端错误
  code | 状态 | 描述
  -- | ---- | --------
  **500** | Internal Server Error	|请求未完成。服务器遇到不可预知的情况。
  501 | Not Implemented	|请求未完成。服务器不支持所请求的功能。
  502 | Bad Gateway	请求未完成。|服务器从上游服务器收到一个无效的响应。
  503 | Service Unavailable	|请求未完成。服务器临时过载或当机。
  504 | Gateway Timeout	|网关超时。
  505 | HTTP Version Not Supported|	服务器不支持请求中指明的HTTP协议版本。

## 缓存相关
  ### 强缓存
  1. http1.0 时代，给客户端设定缓存方式可通过两个字段—— `Pragma` 和 `Expires` 来规范。
  - `Pragma` 字段值为 `no-cache `的时候（事实上现在 RFC 中也仅标明该可选值），会通知客户端**不要对该资源读缓存**，即每次都得向服务器发一次请求才行。且 `Pragma` 的优先级高于 `Cache-Control`。
  - `Expires` 的值对应一个 GMT（格林尼治时间），比如 Mon, 22 Jul 2002 11:12:01 GMT 来告诉浏览器**资源缓存过期时间**，如果还没过该时间点则不发请求。`Expires` 所定义的缓存时间是**相对服务器上的时间**而言的。
  - 如果 `Pragma` 头部和 `Expires` 头部同时存在，则起作用的会是 `Pragma`
  2. http1.1 新增了 `Cache-Control` 来定义缓存过期时间, 在 RFC 中规范了 `Cache-Control` 的格式为：
  - 作为请求头：

    ![cache-control-client](./images/cache-control-client.png)
  - 作为响应头：

    ![cache-control-server](./images/cache-control-server.png)

  ### 协商缓存
  1. `Etag` 和 `If-None-Match`
  - `Etag` 和 `If-None-Match` 返回的是一个校验码。**ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化**。服务器根据请求头中的的 `If-None-Match` 值来判断是否命中缓存。
  2. `Last-Modify` 和 `If-Modify-Since`
  - 浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 `Last-Modify`，`Last-modify` 是一个时间标识该资源的最后修改时间。当浏览器再次请求该资源时，request 的请求头中会包含 `If-Modify-Since`，该值为缓存之前返回的 `Last-Modify`。服务器收到 `If-Modify-Since` 后，**根据资源的最后修改时间判断是否命中缓存**。如果命中缓存，则返回 `304`，并且不会返回资源内容，也不会返回 `Last-Modify`。
  3. `Last-Modified`与 `ETag` 是可以一起使用的，服务器会优先验证 `ETag`，一致的情况下，才会继续比对 `Last-Modified`，最后才决定是否返回 `304`。

  ### 缓存头部对比
| 头部          | 优势和特点                                                                                                           | 劣势和问题                                                                                                                                                                                                                          |
| ------------- | -------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Expires       | 1. HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用，简单易用。2. 以时刻标识失效时间。                                       | 1. 时间是由服务器发送的(UTC)，如果服务器时间和客户端时间存在不一致，可能会出现问题。2. 存在版本问题，到期之前的修改客户端是不可知的。                                                                                               |
| Cache-Control | 1. HTTP 1.1 产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题。2. 比Expires多了很多选项设置。  | 1. HTTP 1.1 才有的内容，不适用于HTTP 1.0 。2. 存在版本问题，到期之前的修改客户端是不可知的。                                                                                                                                        |
| Last-Modified | 1. 不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。  | 1. 只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。2. 以时刻作为标识，无法识别一秒内进行多次修改的情况。3. 某些服务器不能精确的得到文件的最后修改时间。 |
| ETag          | 1. 可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。2. 不存在版本问题，每次请求都回去服务器进行校验。 | 1. 计算ETag值需要性能损耗。2. 分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时发现ETag不匹配的情况。                                                        |
